# -*- coding: utf-8 -*-
"""py_collections_lists_tuples.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Zn6ymIQi8fgT7Vy5ooei_WRRc7wTUliV

# Listas e Operacoes
"""

age_01 = 39
age_02 = 30
age_03 = 27
age_04 = 18

print(age_01)
print(age_02)
print(age_03)
print(age_04)

ages = [39, 30, 27, 18]
type(ages)

len(ages)

ages[0]

ages

ages.append(15)

ages

ages[4]

for age in ages:
  print(age)

ages.remove(30)

ages

ages.append(15)

ages

ages.remove(15)

ages

ages.append(27)
ages.remove(27)
ages

28 in ages

15 in ages

if 15 in ages:
  ages.remove(15)

ages

ages.clear()
ages

ages = [39, 18, 15, 27]
ages

"""*Adicionando elementos em uma lista :*

```
# Adicionando 1 elemento em 1 posicao 
```
"""

ages.insert(0, 20)
ages

"""

```
# Adicionando varios elementos em 1 lista, ou elementos de uma lista em outra lista.
```

"""

new_ages = [19, 21, 40]
ages.extend(new_ages)
ages

"""
```
# Descobrindo idades do proximo ano
```
"""

ages_next_year = []
for age in ages:
    ages_next_year.append(age + 1)
ages_next_year

"""

```
# List comprehension
```

"""

ages_next_year = [(age + 1) for age in ages]
ages_next_year

[(age) for age in ages if age > 21]

def next_year(age):
  return age + 1

[next_year(age) for age in ages if age > 21]

"""# Tuplas"""

class CorrentAccount:

  def __init__(self, code):
    self.code = code
    self.balance = 0

  def deposit(self, value):
    self.balance += value
  
  def __str__(self):
    return (f" Code: {self.code} >> Balance: {self.balance}")

account_01 = CorrentAccount(15)
print(account_01)

account_02 = CorrentAccount(5121)
print(account_02)

accounts = [account_01, account_02]
print(accounts)

for account in accounts:
  print(account)

account_01.deposit(100)
account_02.deposit(500)

for account in accounts:
  print(account)

def deposit_for_all_accounts(accounts):
  for account in accounts:
    account.deposit(100)

accounts = [account_01, account_02]
print(accounts[0], accounts[1])
deposit_for_all_accounts(accounts)
print(accounts[0], accounts[1])

"""
```
# Para sequencia de elementos com tipos diferentes que nao sao mutaveis ultilizamos tupla. (posicao especificas, coisas diferentes)
```

"""

igor = ('Igor', 20, 2000)  # tupla
amanda = ('Amanda', 20, 2001)

# Paulo = (39, 'Paulo', 1998) # ruim

igor.append(5123)

account_01 = (15, 1000)
# account_01.deposit() # variacao OO

print(account_01[1])

account_01[1] += 10

def deposit(account): # Modelo Procedural (Separando comportamento dos dados)
  new_balance = account[1] + 100
  code = account_01[0]
  return (code, new_balance)

account_01

account_01 = deposit(account_01)
account_01

users = [igor, amanda]
users

users.append(('Paulo', 21, 1999))
users

account_01 = CorrentAccount(15)

accounts = (account_01, account_02) # tuplas de objetos (podemos mudar o objeto, mas a tupla nao)

for account in accounts:
  print(account)

accounts[1].deposit(500)

accounts

for account in accounts:
  print(account)

"""# Polimorfismo e arrays

#### Heranca e polimorfismo
"""

class Account:

  def __init__(self, code):
    self._code = code
    self._balance = 0

  def deposit(self, value):
    self._balance += value
  
  def __str__(self):
    return (f" Code: {self._code} >> Balance: {self._balance}")

print(Account(88))

class CorrentAccount(Account):

  def spend_month(self):
    self._balance -= 2

class SavingsAccount(Account):
  
  def spend_month(self):
    self._balance *= 1.01
    self._balance -= 3

account_16 = CorrentAccount(16)
account_16.deposit(1000)
account_16.spend_month()
print(account_16)

account_17 = SavingsAccount(17)
account_17.deposit(2000)
account_17.spend_month()
print(account_17)

account_16 = CorrentAccount(16)
account_16.deposit(1000)
account_17 = SavingsAccount(17)
account_17.deposit(2000)
accounts = [account_16, account_17]

for account in accounts:
  account.spend_month() # Duck Typing
  print(account)

"""#### Array ( Evitaremos ultilizar )

"""

import array as arr

arr.array('d', [1, 3.5])

"""Onde seria viável utilizarmos o array, existe uma biblioteca que consegue ser mais recomendada para realização da tarefa, como trabalhar com números e dados matemáticos específicos, estamos falando da biblioteca *numpy*, **bastante utilizada na área de data science.**




```
import numpy as np
```


"""

import numpy as np

numbers = np.array([1, 3.5])
numbers

numbers + 3

"""#### Metodo Abstrato

"""

class Account:

  def __init__(self, code):
    self._code = code
    self._balance = 0

  def deposit(self, value):
    self._balance += value
  
  def __str__(self):
    return (f" Code: {self._code} >> Balance: {self._balance}")

class CorrentAccount(Account):

  def spend_month(self):
    self._balance -= 2

class SavingsAccount(Account):
  
  def spend_month(self):
    self._balance *= 1.01
    self._balance -= 3

class InvestementAccount(Account):
  pass

InvestementAccount(600)

"""Foi possível criar uma conta investimento mesmo sem ter o método de passar o mês **spend_month**, mas para forçar toda conta que será herdeira da classe *Account* a ter esse método devemos utilizar o *abstractMethod*

OU SEJA, QUER FORCAR AS CLASSE TUDO QUE HERDA DA MAE TER O METODO X? SO COLOCA O METODO COMO METODO ABSTRATO, TAAAAAAAA?

```
import abc from ABCMeta, abstractmethod
```


"""

from abc import ABCMeta, abstractmethod

class Account(metaclass=ABCMeta):

  def __init__(self, code):
    self._code = code
    self._balance = 0

  def deposit(self, value):
    self._balance += value
  
  @abstractmethod
  def spend_month(self):
    pass

  def __str__(self):
    return (f" Code: {self._code} >> Balance: {self._balance}")

class CorrentAccount(Account):

  def spend_month(self):
    self._balance -= 2

class SavingsAccount(Account):
  
  def spend_month(self):
    self._balance *= 1.01
    self._balance -= 3

class InvestementAccount(Account):
  pass

print(Account(17))

print(InvestementAccount(20))

CorrentAccount(100)

SavingsAccount(131)



"""# Igualdade"""

